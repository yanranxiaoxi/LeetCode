每日一题 2022.03.23

## 题目

给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。

## 解题思路

将 `$n` 构造成以 1～9 为根的 9 颗 10 叉数，每一层的节点都是 0～9 十个子节点，以 1 开头的数字肯定都小于以 2 开头的数字。

在此数据结构的模型下，我们按如下步骤找目标数字。

1. 通过计算每颗树节点个数（包含数字个数），找到数字会落在哪颗树上。

2. 在目标树内逐个子树寻找目标，假如以 1 开头的树共含 90 个数字，我们要找第 17 个，那我们知道肯定在这颗树里面了，然后我把指针指向下一层 10，假如以 10 开头的子树有 10 个节点，那肯定不在 10 开头的子树里面了，则往下一个节点找 11（此时我们相当于找过 10 个节点了），假如也有 10 个，则肯定在 11 开头的子树下，再往下一层，110，无子节点（只包含一个树）再找 111、类似 112、113 直到 `k`。

思路有了，但我们有个问题，如何确定以 `$i` 开头的树有多少节点？

我们可以给他逐渐增位数，比如以 1 开头的个数（178 以内的树，找第 165 个），首先只有一位，那只能是 1，他的下一个量级数是 2（2 - 1 = 1 个）；增加位数 10，下一量级数是 20，则 10～19 都是小于 20（20 - 10 = 10 个）；再增加位数 100，下一量级的数需要注意边界了，我们不能超 178，所以是 100～178（179 - 100 = 79 个）。

## 题解

### PHP

```PHP
class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return Integer
     *
     * 思路：
     * 以 $prefix 开头的数字，组成一个 10 叉树，每一个父节点都有 0～9 10 个子节点。如 178 以下，以 1 开头的
     * 数字为 1；10～19（1 为父节点 0～9 为子节点）;100~178（不能超最大）
     *
     * 先确定在以哪个 $prefix 开头的树下面（通过计算个数，比如第 165 个数，以 1 开头的有 90 个，则不在
     * 此，继续找下一个开头的 2。还不够，一直找到 8 开头下面共 167 个超过 165，则肯定在 8 开头的树下，再顺
     * 着节点往下一层找）
     */
    function findKthNumber($n, $k) {
        $prefix = 1;
        $i = 1;
        while($i < $k) {
            //计算以 $prefix 开头的数字有多少个
            $count = $this->calCount($prefix, $n);
            if ($i + $count <= $k) {
                //以 $prefix 开头的数的个数 + 1 小于等于 $k，说明以 $prefix 开头的数量不够，指针转向 $prefix + 1 开头的数
                $prefix = $prefix + 1;
                $i += $count;
            } else {
                //以 $prefix 开头的数大于 $k 说明必在其中，指针指向字典序的下一个，下一循环看在不在此指针开头的数中
                $prefix = $prefix * 10;
                $i++; 
            }
        }
        return $prefix;
    }

    /**
     * 计算以 $prefix 开头的数字有多少个
     * 因为以 1 开头的数字都比以 2 开头的数字少，因此逐位增加计算，但是不超最大 $n 限制。
     * 如 178 以内以 1 开头的个数： 1 < 2 (2 - 1 = 1 个)；10~19 < 20 (20 - 10 = 10 个)；100～178 < 200 (179 - 110 = 79 个)，共计 1 + 10 + 79 = 90 个
     */
    function calCount($prefix, $n)
    {
        $next = $prefix + 1;
        $count = 0;
        while ($prefix <= $n) {
            $count += min($next, $n + 1) - $prefix;
            $prefix = $prefix * 10;
            $next = $next * 10;
        }
        return $count;
    }
}
```

## 复杂度分析

- 时间复杂度：$O(log^n)$
- 空间复杂度：$O(1)$
