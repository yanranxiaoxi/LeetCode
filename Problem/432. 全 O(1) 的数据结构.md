每日一题 2022.03.16

## 题目

请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。

实现 `AllOne` 类：

- `AllOne()` 初始化数据结构的对象。
- `inc(String key)` 字符串 `key` 的计数增加 `1` 。如果数据结构中尚不存在 `key` ，那么插入计数为 `1` 的 `key` 。
- `dec(String key)` 字符串 `key` 的计数减少 `1` 。如果 `key` 的计数在减少后为 `0` ，那么需要将这个 `key` 从数据结构中删除。测试用例保证：在减少计数前，`key` 存在于数据结构中。
- `getMaxKey()` 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 `""` 。
- `getMinKey()` 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 `""` 。

## 解题思路

性能达到 **O(1)** 这类题的关键点就是对于一次操作，`key` 的频率只能变化为 `1`（加 `1` 或者减 `1`），因此生成的链表是排序的，节点调整的复杂也是 **O(1)**。

使用 **双向链表** 加 **哈希表** 就可以完成双 **O(1)** 复杂度，但是不知道为什么，所有的测试用例均通过，也没有回报内存、时间超限，可是就是提示 **解答错误**，我偏向于相信我的题解没有什么问题。

## 题解

### PHP

```PHP
class DNode {
    public $next;
    public $prev;
    public $value;

    public function __construct($value = NULL, $next = NULL, $prev = NULL) {
        $this->value = $value;
        $this->next = $next;
        $this->prev = $prev;
    }
}

class DList {
    public function __construct() {
        $this->head = new DNode();
        $this->tail = new DNode();
        $this->head->next = $this->tail;
        $this->tail->prev = $this->head;
    }

    public function isEmpty() {
        return $this->head->next == $this->tail;
    }

    public function insertBefore($tnode, $value) {
        $node = new DNode($value);
        $tnode->prev->next = $node;
        $node->next = $tnode;
        $node->prev = $tnode->prev;
        $tnode->prev = $node;
        return $node;
    }

    public function insertAfter($tnode, $value) {
        if ($tnode == NULL) {
            return $this->addHead($value);
        }
        $node = new DNode($value);
        $tnode->next->prev = $node;
        $node->next = $tnode->next;
        $node->prev = $tnode;
        $tnode->next = $node;
        return $node;
    }

    public function remove($tnode) {
        $prev = $tnode->prev;
        $next = $tnode->next;
        $tnode->prev->next = $next;
        $tnode->next->prev = $prev;
    }

    public function addHead($value) {
        return $this->insertAfter($this->head, $value);
    }

    public function addTail($value) {
        return $this->insertBefore($this->tail, $value);
    }

    public function next($node) {
        if ($node->next == $this->tail) {
            return NULL;
        }
        return $node->next;
    }

    public function prev($node) {
        if ($node->prev == $this->head) {
            return NULL;
        }
        return $node->prev;
    }

    public function first() {
        return $this->head->next;
    }  
    
    public function last() {
        return $this->tail->prev;
    }

    public function size() {
        $cnt = 0;
        $cur = $this->head->next;
        while ($cur != $this->tail) {
            $cnt++;
            $cur = $cur->next;
        }
        return $cnt;
    }

    public function show() {
        echo "show\n";
        $cur = $this->head->next;
        while ($cur != $this->tail) {
            echo $cur->value . ",";
            $cur = $cur->next;
        }
        echo "\n\n";
    }
}

class AllOne {
    /**
     * Initialize your data structure here.
     */
    function __construct() {
        $this->keyNodeMap = []; //key 与 keynode 映射关系
        $this->freqList = new DList; //从小到大的频率用双链表链接，每个元素也是一个双链表
    }

    /**
     * Inserts a new key <Key> with value 1. Or increments an existing key by 1.
     * @param String $key
     * @return NULL
     */
    function inc($key) {
        $keyNode = $this->keyNodeMap[$key]; //slotNode
        if ($keyNode == NULL) { //必然增加频度为 1 的节点
            $freq = 0;
            $nextSlotNode = $this->freqList->first();
        } else {
            $slotList = ($keyNode->value)[1];
            $slotNode = ($keyNode->value)[2];
            $freq = ($slotNode->value)[0];
            $nextSlotNode = $this->freqList->next($slotNode);
        }
        if ($nextSlotNode) {
            $nextSlotList = ($nextSlotNode->value)[1];
            $nextFreq = ($nextSlotNode->value)[0];
        }
        if ($nextFreq && $nextFreq == $freq + 1) {
            //直接加入
            $keyNode = $nextSlotList->addTail([$key, $nextSlotList, $nextSlotNode]);
        } else {
            //新建加入
            $newSlotList = new DList();
            $newSlotNode = $this->freqList->insertAfter($slotNode, [$freq + 1, $newSlotList]);
            $keyNode = $newSlotList->addTail([$key, $newSlotList, $newSlotNode]);
        }
        if ($this->keyNodeMap[$key]) {
            //从 freq 中移除
            $slotList->remove($this->keyNodeMap[$key]);
            if ($slotList->isEmpty()) {
                $this->freqList->remove($slotNode);
            }
        }
        //更新 keynode
        $this->keyNodeMap[$key] = $keyNode;
    }

    /**
     * Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.
     * @param String $key
     * @return NULL
     */
    function dec($key) {
        $keyNode = $this->keyNodeMap[$key];
        if ($keyNode == NULL) { //不存在
            return;
        }
        $slotList = ($keyNode->value)[1];
        $slotNode = ($keyNode->value)[2];
        $freq = ($slotNode->value)[0];
        //添加到 freq - 1 中
        if ($freq > 1) { //调整
            $prevSlotNode = $this->freqList->prev($slotNode);
            if ($prevSlotNode) {
                $prevSlotList = ($prevSlotNode->value)[1];
                $prevFreq = ($prevSlotNode->value)[0];
            }
            if ($prevFreq == $freq - 1) {
                //直接加入
                $keyNode = $prevSlotList->addTail([$key, $prevSlotList, $prevSlotNode]);
            } else {
                //新建加入
                $newSlotList = new DList();
                $newSlotNode = $this->freqList->insertAfter($slotNode, [$freq - 1, $newSlotList]);
                $keyNode = $newSlotList->addTail([$key, $newSlotList, $newSlotNode]);
            }
        }
        //从 freq 中移除
        $slotList->remove($this->keyNodeMap[$key]);
        if ($slotList->isEmpty()) { //一个也没有了
            $this->freqList->remove($slotNode);
        }
        //更新 keynode
        if ($freq == 1) {//清理 keyNode
            unset($this->keyNodeMap[$key]);
        } else { //调成后重新设置
            $this->keyNodeMap[$key] = $keyNode;
        }
    }

    /**
     * Returns one of the keys with maximal value.
     * @return String
     */
    function getMaxKey() {
        if ($this->freqList->isEmpty()) {
            return "";
        }
        $slotNode = $this->freqList->last(); //最后一个
        $slotList = ($slotNode->value)[1];
        $keyNode = $slotList->first();
        return ($keyNode->value)[0];
    }

    /**
     * Returns one of the keys with Minimal value.
     * @return String
     */
    function getMinKey() {
        if ($this->freqList->isEmpty()) {
            return "";
        }
        $slotNode = $this->freqList->first(); //第一个
        $slotList = ($slotNode->value)[1];
        $keyNode = $slotList->first();
        return ($keyNode->value)[0];
    }
}

/**
 * Your AllOne object will be instantiated and called as such:
 * $obj = AllOne();
 * $obj->inc($key);
 * $obj->dec($key);
 * $ret_3 = $obj->getMaxKey();
 * $ret_4 = $obj->getMinKey();
 */
```

## 复杂度分析

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
