## 题目

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

## 解题思路

典型的滑动窗口问题，*不过也可以用双指针解决*。

- 先设定 **第一棵果树** 的位置，并记录第一棵果树的水果类型，然后从这颗果树开始往右寻找一棵 **水果类型不同** 的果树，记录下该果树的类型（作为 **第二棵果树** 的类型）。
- 继续向右找寻果树，直到出现一棵果树的水果类型与前面记录的两棵果树的水果类型 **均不相同**。
- 将此时采摘的水果数量记录下来，与之前的记录（如果存在）比对，如若大于之前的记录，则覆盖之前的记录，并将 **第一棵果树** 的位置 **向右设置一位**。
- 重复循环，直到没有果树可找。

## 题解

### C++

```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int one = 0;
        int two = 0;
        int result = INT32_MIN;
        int subLength;
        int j = 0;
        for (int i = 0; i < fruits.size(); i++) { //左滑窗口 找到可行解
            one = fruits[i]; //记录第一种水果
            for (int k = i + 1; k < fruits.size(); k++) { //寻找可以采摘的第二种水果
                if (fruits[k] != fruits[i]) { //找到第二种水果
                    two = fruits[k];
                    //j = k; // j 从寻找到的第二种水果位置开始找（时间翻倍了）
                    break; //不再继续找水果
                }
            }
            while (fruits[j] == one || fruits[j] == two) { //找到的满足采摘的两种水果
                subLength = j - i + 1; //记录当前的长度
                result = subLength > result ? subLength : result; //寻找最优解
                j++;
                if (j == fruits.size()) { //找完了
                    return result == INT32_MIN ? 0 : result;
                }
            } 
        }
        return 0;
    }
};
```
